#define INTP_NMAX 40000
c-----------------------------------------------------------------------
      subroutine userchk
      use stdlib_logger, only: debug_level, information_level
      use LightKrylov, only: zero_basis
      use LightKrylov_Logger
      use neklab
      include "SIZE"
      include "TOTAL"

      ! System for which we seek a fixed point
      type(nek_system_temp), allocatable :: sys
      type(exptA_linop_temp), allocatable :: exptA_temp

      ! State vectors
      type(nek_dvector) :: bf

      ! Tolerance for the Newton solver
      real(dp) :: tol
      type(nek_dvector), allocatable :: eigvecs(:)
      complex(kind=dp), allocatable :: eigvals(:)
      real(kind=dp), allocatable :: residuals(:)
      integer :: info
      character(len=3) :: file_prefix

      ! Stability analysis parameters
      integer, parameter :: kdim = 128, nev = 2

      if (istep.eq.0) then
         ! Setup logger
         call logger_setup(nio=0, log_level=information_level, log_stdout=.false., log_timestamp=.true.)
            
         ! Load initial guess
         call load_fld('BF_Ra500_tsyphon0.f00001')
         call nek2vec(bf, vx, vy, vz, pr, t)
         
         ! Define system
         sys = nek_system_temp()
         sys%jacobian = nek_jacobian_temp()
         sys%jacobian%X = bf
			
         ! Set Newton tolerance
         tol = 1.0e-6_dp
         
         ! Compute fixed point
         call newton_fixed_point_iteration(sys, bf, tol, tol_mode=2)

         !Outpost solution
         call outpost_dnek(bf, "BF_")

         ! Exponential propagator
         exptA_temp = exptA_linop_temp(1.0_dp, bf) ; call exptA_temp%init()
         allocate (eigvecs(nev)); call zero_basis(eigvecs)

         call eigs(exptA_temp, eigvecs, eigvals, residuals, info, kdim=kdim, write_intermediate=.true.)

         ! Transform eigenspectrum to continuous-time representation.
         eigvals = log(eigvals)/exptA_temp%tau
      
         ! Determine the file prefix.
         file_prefix = "dir"
      
         ! Save eigenspectrum to disk.
         call save_eigenspectrum(eigvals, residuals, trim(file_prefix)//"_eigenspectrum.npy")
      
         ! Export eigenfunctions to disk.
         call outpost_dnek(eigvecs(:nev), file_prefix)

         call nek_end()
      end if

      call compute_flow_rate(flow_rate)

      return
      end
c-----------------------------------------------------------------------
      subroutine userf (ix,iy,iz,ieg)
      use neklab, only: neklab_forcing
      implicit none
      include 'SIZE'
      include 'SOLN'            ! jp
      include 'NEKUSE'          ! FFX, FFY, FFZ
      include 'PARALLEL'        ! GLLEL
      integer ix,iy,iz,ieg,ip,iel
      real rtmp, uparam, param
      logical ifheat
 
      ffx = 0.0d0
      ffy = 0.0d0
      ffz = 0.0d0

      if(ifheat.and.uparam(06).gt.0)then
      iel = gllel(ieg)
      ip = ix + nx1*(iy-1+ny1*(iz-1+nz1*(iel-1)))
      if (jp .eq. 0) rtmp = t(ix, iy, iz, iel, 1)
      if (jp .eq. 1) rtmp = tp(ip, 1, 1)
      
                 ! Pr         ! Ra
      ffy = rtmp*abs(param(2)*uparam(6))
      endif
      
      call neklab_forcing(FFX,FFY,FFZ,ix,iy,iz,ieg,jp)

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      if (JP.eq.0) then         ! velocity
         ux= 0.0d0
         uy= 0.0d0
         uz= 0.0d0
         temp= 0.50d0*(1.0d0 + tanh(-20.0d0*y))
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif

      
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      if (JP.eq.0) then         ! velocity
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp= 0.50d0*(1.0d0 + tanh(-20.0d0*y))
      else                      ! perturbation
         ux = 0.0d0
         uy = 0.0d0
         uz = 0.0d0
         temp = 0.0d0
      endif
      
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      end
c-----------------------------------------------------------------------
      subroutine usrdat2      
      end
c-----------------------------------------------------------------------
      subroutine compute_flow_rate(flow_rate)
      include 'SIZE'
      include 'TOTAL'

      parameter (npts = 101)

!     --> Array to store the data points.
      real xyz(ldim, npts)
      save xyz

!     --> Array to store the interpolated velocities.
      real uvw(ldim, npts)

!     --> Flow rate.
      real flow_rate

      if (istep.EQ.0) then
!     -- > Open file to store the flow rate.
         if (nid.EQ.0) open(unit=1234, file="flow_rate.dat")

!     -- > Location of points.
         xyz(1, :) = 0.0D+00
         xyz(2, :) = 0.0D+00
         if (if3D) xyz(3, :) = 0.0D+00

         do i = 1,npts
            xyz(2, i) = 1.0D+00 + (i-1)*0.01
         enddo
         
      endif

!     --> Get the velocities at the points locations.
      call interp_v(uvw, xyz, npts)

!     --> Use simple integration.
      flow_rate = sum(uvw(1, :)) * 0.01

      if ((nid.EQ.0) .and. (mod(istep, 10).EQ.0)) then
         write(1234, *) time, flow_rate
      endif

      if (istep.EQ.nsteps) then
         if (nid.EQ.0) close(1234)
      endif
      
      
      end
c-----------------------------------------------------------------------
      subroutine interp_v(uvw, xyz, n)
      include 'SIZE'
      include 'TOTAL'
      
      real uvw(ldim,n),xyz(ldim,n)
      
      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)  ! code, proc, el
      save    rwk, iwk
      
      integer intp_h
      save    intp_h
      
      common /rwk_intp/ 
     $     fwrk(lx1*ly1*lz1*lelt,ldim),
     $     fpts(ldim*INTP_NMAX),
     $     pts(ldim*INTP_NMAX)
      
      integer icalld,e
      save    icalld
      data    icalld /0/
      
      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt
      
      if (n.gt.INTP_NMAX) call exitti ('n > INTP_NMAX in interp_v!$',n)
      
      if (nelgt.ne.nelgv) call exitti
     $     ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)
      
      do i=1,n                  ! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
 !        if (if3d) pts(i + n*2) = xyz(3,i)
      enddo
      
      if (icalld.eq.0) then
         icalld = 1
         call interp_setup(intp_h,0.0,0,nelt)
      endif
      
! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)
      
! interpolate
      call interp_nfld(fpts,fwrk,ndim,pts(1),pts(1+n),pts(2*n+1),
     $     n,iwk,rwk,INTP_NMAX,.true.,intp_h)
      
      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n)
!         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo
      
      end
c-----------------------------------------------------------------------
